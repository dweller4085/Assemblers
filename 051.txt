#define n 6
#define m 5

char * format = "(%d, %d)\n";
int specialElementCount;
int matrix[n*m];

Текст программы:
01          mov ecx, n-1
02  ITROW:  mov edx, m-1
03  ITCOL:  mov esi, edx
04          mov eax, m
05          mul ecx
06          add eax, esi
07          lea ebx, [matrix + 4 * eax]
08          mov edi, ebx
09          mov eax, [ebx]
10          mov edx, esi
11  CHECKL: sub ebx, 4
12          dec edx
13          jl NEXT
14          cmp eax, [ebx]
15          jge BAD
16          jmp CHECKL
17  NEXT:   mov ebx, edi
18          mov edx, esi
19  CHECKR: add ebx, 4
20          inc edx
21          cmp edx, m
22          jz GOOD
23          cmp eax, [ebx]
24          jle BAD
25          jmp CHECKR
26  GOOD:   inc [specialElementCount]
27          push esi
28          push ecx
29          push dword ptr [format]
30          call printf
31          pop eax
32          pop ecx
33          pop edx
34  BAD:    mov edx, esi
35          dec edx
36          jge ITCOL
37          dec ecx
38          jge ITROW



Программа проверяет каждый элемент матрицы на "особенность" по определению.
Обход по элементам осуществляется двойным циклом:

01          mov ecx, n-1
02  ITROW:  mov edx, m-1
03  ITCOL:  mov esi, edx
..          (...)
35          dec edx
36          jge ITCOL
37          dec ecx
38          jge ITROW

Регистр ecx соответствует индексу строки текущего элемента и проходит от n-1 до 0.
Регистр edx соответствует индексу столбца текущего элемента и проходит от m-1 до 0.

В теле (...) осуществлен следующий алгоритм:
1)  Проходим по всем элементам слева от текущего элемента (i, j).
Если нашелся такой элемент, который больше или равен текущему - то заведомо текущий элемент не 
может быть особенным. Переходим в конец тела цикла. Если же все элементы слева меньше текущего 
элемента - то переходим в пункт 2).

2)  Проходим по всем элементам справа от текущего элемента (i, j).
Если нашелся такой элемент, который меньше или равен текущему - то заведомо текущий элемент не 
может быть особенным. Переходим в конец тела цикла. Если же все элементы слева больше текущего 
элемента - то значит мы нашли особый элемент. Печаем координаты особого элемента, инкрементируем 
счетчик особых элементов. Переходим в конец цикла.


Более подробно:

03  ITCOL:  mov esi, edx                 Сохраняем текущий индекс столбца (edx) в регистр esi.
04          mov eax, m                   Вычисляем смещение для текущего элемента по формуле
05          mul ecx                      i*m + j = m * ecx + esi.
06          add eax, esi                 
07          lea ebx, [matrix + 4 * eax]  Загружаем в ebx адрес текущего элемента.  
08          mov edi, ebx                 Сохраняем ebx в edi.
09          mov eax, [ebx]               Копируем в eax числовое значение текущего элемента.
10          mov edx, esi                 Восстанавливаем значение edx, которое поменялось при  
                                         операции mul.


11  CHECKL: sub ebx, 4                   Смещаем указатель элемента матрицы на один влево.
12          dec edx                      Декрементируем индекс столбца на один.
13          jl NEXT                      Проверяем, не вышли ли за границу [0, j).
14          cmp eax, [ebx]               Рассматриваемый элемент меньше или равен текущему?
15          jge BAD                      Да. Текущий элемент - не особенный. В конец цикла.
16          jmp CHECKL                   Нет. Переходим к следующему элементу слева.



17  NEXT:   mov ebx, edi                 Рассмотрели все элементы слева. Теперь рассматриваем
18          mov edx, esi                 элементы справа. Восстанавливаем значения регистров
                                         ebx, edx, хранящих указатель на- и индекс столбца
                                         текущего элемента.


19  CHECKR: add ebx, 4                   Смещаем указатель элемента матрицы на один вправо.
20          inc edx                      Инкрементируем индекс столбца на один.
21          cmp edx, m                   Проверяем, не вышли ли за границу (j, m-1].
22          jz GOOD                      
23          cmp eax, [ebx]               Рассматриваемый элемент больше или равен текущему?
24          jle BAD                      Да. Текущий элемент - не особенный. В конец цикла.
25          jmp CHECKR                   Нет. Переходим к следующему элементу справа.


26  GOOD:   inc [specialElementCount]    Нашли особый элемент. Инкрементируем счетчик, выводим
27          push esi                     координаты.
28          push ecx                     Вывод осуществлен через вызов процедуры printf.
29          push dword ptr [format]      Передаем ей 3 аргумента: указатель на строку формата,
30          call printf                  индексы строки/столбца.
31          pop eax                      
32          pop ecx                      Восстанавливаем регистр ecx - индекс строки!
33          pop edx                      Очищаем стек сами по соглашению о вызове cdecl.

34  BAD:    mov edx, esi                 Конец тела цикла. Восстанавливаем регистр edx.
